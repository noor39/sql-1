-- #############################################################################################################
-- #############################################################################################################
-- ****************************************volume 1 (plsql)************************************************



-- #############################################################################################################
-- #############################################################################################################
-- #############################################################################################################





-- #############################################################################################################
-- #############################################################################################################
-- ****************************************CHAPTER 2 plsql volume 1****************************************

-- #############################################################################################################
-- #############################################################################################################

CREAte , compile and invoke the ADD_JOB procedura and review the results
create a procedure called UPD_JOB to modify a job in the JOBS table;
create a procedure called DEL_JOB to delete a job from the JOBS table;

create a procedure called GET_EMPLOYEE to query the Employees TABLE;
create a procedure called RAISE_SALARY to increase the employee salary;
create a procedure called QUERY_EMP to query the employeee 





-- /1
CREATE OR REPLACE procedure ADD_JOB (p_id jobs.job_id%TYPE, p_title jobs.job_title%TYPE) IS 
BEGIN
insert into jobs (job_id, job_title)
values (p_id , p_title);
END ADD_JOB;
/
-- 2
CREATE OR REPLACE procedure UPD_JOB (p_id jobs.job_id%TYPE, p_title jobs.job_title%TYPE) IS 
BEGIN
UPDATE JOBS SET JOB_ID=p_id
WHERE job_title=p_title;
end UPD_JOB;
/
-- 3
CREATE OR REPLACE procedure DEL_JOB (p_id jobs.job_id%TYPE ) IS 
BEGIN
DELETE FROM  JOBS WHERE  JOB_ID=p_id;
end DEL_JOB;
/
-- 4

CREATE OR REPLACE procedure GET_EMPLOYEE (p_id IN employees.employee_id%TYPE,p_sal OUT employees.salary%TYPE, p_job OUT employees.job_id%TYPE) IS 
BEGIN

SELECT SALARY, job_id INTO p_sal, p_job
FROM EMPLOYEES
WHERE employee_id=p_id;

end GET_EMPLOYEE;
/

VARIABLE v_sal number 
VARIABLE v_job varchar2(15)
EXECUTE GET_EMPLOYEE (100,:v_sal, :v_job);

-- 5

CREATE OR REPLACE procedure RAISE_SALARY (p_id IN employees.employee_id%TYPE,
p_sal OUT employees.salary%TYPE) IS 
BEGIN

SELECT (SALARY+1000) INTO p_sal
FROM EMPLOYEES
WHERE employee_id=p_id;
end RAISE_SALARY;
/

VARIABLE v_sal NUMBER
VARIABLE v_sal NUMBER

-- 6








-- Creating procedures with the sql CREATE OR REPLACE statement
CREATE [OR REPLACE] PROCEDURE procecure_name
[(parameter1 [mode]) datatype1,
  parameter2 [mode]) datatype2,...]
  IS|AS    
--   plsql block
  [local_variable_declarations;...]
  BEGIN 
    --actions;
  END[procecure_name];
--plsql block


-- formal and actual parameters
-- Procedure definition, Formal_parameters
CREATE PROCEDURE raise_sal(p_id NUMBER, p_sal NUMBER) IS 
BEGIN
    ...
END raise_sal;

-- Procedure calling, Actual parameters (arguments)
v_emp_id:=100;
raise_sal(v_emp_id,2000)
-- procedural parameter Modes
CREATE PROCEDURE proc_name(param_name [mode] datatype)
-- using the IN parameter Mode 
CREATE OR REPLACE PROCEDURE raise_salary
(p_id IN employees. employee_id%TYPE,
p_percent IN NUMBER)
IS
BEGIN
    UPDATE employees
    SET salary=salary*(1+p_percent/100)
    WHERE employee_id=p_id;
END raise_salary;

SELECT salary FROM employees where employee_id=176;
EXECUTE raise_salary(176,10)


-- Using the OUT parameter Mode 
CREATE OR REPLACE PROCEDURE query_emp
(p_id IN employees. employee_id%TYPE,
p_name OUT employees.last_name%TYPE,
p_salary OUT employees.salary%TYPE) 
IS
BEGIN 
    SELECT last_name, salary INTO    p_name, p_salary
    FROM employees
    WHERE employee_id=p_id;
END query_emp;
/




SET SERVEROUTPUT ON
DECLARE 
    v_emp_name employees.last_name%TYPE;
    v_emp_sal employees.salary%TYPE;
BEGIN
    query_emp(171,v_emp_name, v_emp_sal);
    DBMS_OUTPUT.PUT_LINE(v_emp_name||' earns '||TO_CHAR(v_emp_sal,'$999,999.00'));--to char kore dilam jate salary number ta varchar hishebe ashe
END;
/

-- Using the IN OUT parameter mode 
CREATE OR REPLACE PROCEDURE format_phone
(p_phone_no IN OUT VARCHAR2) IS
BEGIN
    p_phone_no:='('||SUBSTR(p_phone_no,1,3)||
                ')'||SUBSTR(p_phone_no,1,3)||
                '-'||SUBSTR(p_phone_no,7);
END format_phone;
/

VARIABLE b_phone_no VARCHAR2(15)
EXECUTE :b_phone_no:='01704030009'
PRINT b_phone_no
EXECUTE format_phone(:b_phone_no)
PRINT b_phone_no

-- viewing the OUT parameters:
--  using the DBMS_OUTPUT.PUT_LINE subroutine
SET SERVEROUTPUT ON

DECLARE
    v_emp_name employees.last_name%TYPE;
    v_emp_sal employees.salary%TYPE;
BEGIN
    query_emp(171,v_emp_name, v_emp_sal);
    DBMS_OUTPUT.PUT_LINE('Name: '||v_emp_name);
    DBMS_OUTPUT.PUT_LINE('Salary: '||v_emp_sal);
END;

-- viewing OUT parameters 
VARIABLE b_name VARCHAR2(25)
VARIABLE b_sal NUMBER
EXECUTE b_name b_sal


-- passing Actual Parameters:
-- creating the add_dept procedure
CREATE OR REPLACE PROCEDURE add_dept(
    p_name IN departments.department_name%TYPE,
    p_loc IN departments.location_id%TYPE)
    IS
    BEGIN
        INSERT INTO departments(department_id,department_name,location_id)
        VALUES (departments_seq.NEXTVAL,p_name,p_loc);
    END add_dept;
    /

    -- Passing Actual Parameters 
    -- Passing Actual Parameters using the Positional notation.
    EXECUTE add_dept('TRAINING',2500)

   -- Passing Actual Parameters using the named notation.
   EXECUTE add_dept(p_loc=>2400,p_name=>'EDUCATION')
    -- Using the DEFAULT option for the parameters
    CREATE OR REPLACE PROCEDURE add_dept(
        p_name departments.department_name%TYPE:='Unknown',
        p_loc departments.location_id%TYPE DEFAULT 1700)
    IS 
    BEGIN
        INSERT INTO departments(department_id, department_name,location_id)
        VALUES(departments_seq.NEXTVAL,p_name,p_loc);
    END add_dept;
    /

    EXECUTE add_dept
    EXECUTE add_dept ('ADVERTISING',p_loc=>1200)
    EXECUTE add_dept (p_loc=>1200)

    select department_id, department_name, location_id from departments;

    -- Calling procedures
    CREATE OR REPLACE PROCEDURE process_employees
    IS 
        CURSOR cur_emp_cursor IS
        SELECT employee_id
        FROM employees;
    BEGIN
        FOR emp_rec IN cur_emp_cursor
        LOOP
            raise_salary(emp_rec.employee_id,10);
        END LOOP;
        COMMIT;
    END process_employees;
    /
    EXECUTE process_employees;
    -- Handled Exceptions
    CREATE PROCEDURE add_department(
        p_name VARCHAR2,p_mgr NUMBER,p_loc NUMBER) IS  
    BEGIN 
        INSERT INTO departments(department_id,department_name, manager_id, location_id)
        VALUES (departments_seq.NEXTVAL,p_name,p_mgr,p_loc);
        DBMS_OUTPUT.PUT_LINE('Added Dept:'||p_name);
    EXCEPTION
        WHEN OTHERS THEN   
        DBMS_OUTPUT.PUT_LINE('Err: adding dept: '||p_name);
    END;
/
    CREATE PROCEDURE create_departments IS    
    BEGIN 
        add_department('Media',100,1800);
        add_department('Editing',99,1800);
        add_department('Advertising',101,1800);
    END;
/
-- Exceptions Not Handled 
SET SERVEROUTPUT ON 
CREATE PROCEDURE add_department_noex(
    p_name VARCHAR2,p_mgr NUMBER,p_loc NUMBER
) IS    
BEGIN
    INSERT INTO DEPARTMENTS(department_id,
    department_name,manager_id,location_id)
    VALUES(departments_seq.NEXTVAL,p_name,p_mgr,p_loc);
    DBMS_OUTPUT.PUT_LINE('Added Dept: '||p_name);
END;
/

CREATE PROCEDURE create_departments_noex IS     
BEGIN 
    add_department_noex ('Media',100,1800);
 add_department_noex ('Editing',99,1800);
 add_department_noex ('Advertising',101,1800);
END;
/
EXECUTE create_departments_noex;
-- removing procedures using the drop 
DROP Procedure raise_salary;

-- viewing procedure information using the data dictionary views 
DESCRIBE user_source

SELECT text 
FROM user_source
WHERE name='ADD_DEPT' AND type= 'PROCEDURE'
ORDER BY line;
-- Subprogram with a BOOLEAN Parameter
CREATE OR REPLACE PROCEDURE p(x BOOLEAN) AUTHID
CURRENT_USER AS   
BEGIN

    IF x THEN   
        DBMS_OUTPUT.PUT_LINE('x is true');
    END IF;
END;
/
DECLARE
b BOOLEAN:=TRUE;
BEGIN
    p(b);
    END;
    /



-- #############################################################################################################
--******************** Chapter 3 creating Funcitons and debugging subprograms
 -- #############################################################################################################


--  creating functions
CREATE  [OR REPLACE] FUCTION function_name
[(parameter1 [mode1] datatype1,...)]
RETURN datatype IS|AS    
[local_variable_declarations;
...]
BEGIN
    --actions;
    RETURN expression;
END [function_name];

-- Creating and Invoking a stored Function Using the CREATE FUNCTION statement
CREATE OR REPLACE FUNCTION get_sal
(p_id employees.employee_id%TYPE) RETURN NUMBER IS     
v_sal employees.salary%TYPE:=0;
BEGIN
    SELECT Salary
    INTO v_sal
    FROM employees
    WHERE employee_id=p_id;
    RETURN v_sal;
END get_sal;
/

-- Invoke the function as an expression or as 
-- a parameter value.
 EXECUTE  DBMS_OUTPUT.PUT_LINE(get_sal(100))

-- Using Different Methods for Executing Functions
-- As a PL/SQL expression , get the results using host variables
SET AUTOPRINT ON
VARIABLE b_salary NUMBER
EXECUTE :b_salary :=get_sal(100)

-- As a PL/SQL expression , get the results using a local variable
SET SERVEROUTPUT ON 
DECLARE 
sal employees.salary%TYPE;
BEGIN
    sal:=get_sal(100);
    DBMS_OUTPUT.PUT_LINE('The salary is: '||sal);
END;
/
-- Using different methods for executing functions
-- Use as a parameter to another subprogram
EXECUTE DBMS_OUTPUT.PUT_LINE(get_sal(100))

-- Use in a SQL statement (subject to restrictions)
SELECT job_id, get_sal(employee_id)
FROM employees;

-- Using a Function in a SQL expression
CREATE OR REPLACE FUNCTION tax(p_value IN NUMBER)  
RETURN NUMBER IS     
BEGIN 
    RETURN (p_value * 0.08);
END tax;
/
SELECT employee_id,last_name, salary,tax(salary)
FROM employees
WHERE department_id=100;


-- Calling User defined functions in sql statements
SELECT employee_id, tax(salary)
FROM employees
WHERE tax(salary)>(SELECT MAX(tax(salary))
                    FROM employees
                    WHERE department_id =30)
ORDER BY tax(Salary) desc;

-- Restrictions on calling  functions from sql

CREATE OR REPLACE FUCTION dml_call_sql(p_sal NUMBER)
    RETURN NUMBER IS     
BEGIN 
    INSERT into employees( employee_id, last_name, email, hire_date,job_id,salary)
    VALUES( 1, 'Frost', 'jfrost@company.com',SYSDATE, 'SA_MAN',p_sal);
    RETURN (p_sal+100);
END;

UPDATE employees
    SET salary =dml_call_sql(2000)
WHERE employee_id =170;



-- 
CREATE OR REPLACE FUNCTION query_call_sql(p_a NUMBER )
RETURN NUMBER IS    
v_s NUMBER;
BEGIN 
    SELECT salary INTO    v_s FROM employees
    WHERE employee_id=170;
    RETURN (v_s+p_a);
END;


Update employees SET salary =query_call_sql(100)
WHERE employee_id =170;


-- Named and Mixed Notationj From sql
CREATE OR REPLACE FUNCTION f(
    p_parameter_1 IN NUMBER DEFAULT 1,
    p_parameter_e IN NUMBER DEFAULT 5)
RETURN NUMBER
IS     
v_var NUMBER;
BEGIN 
    v_var :=p_parameter_1+(p_parameter_5*2);
RETURN v_var;
END f;
/
SELECT f(p_parameter_5 =>10) FROM DUAL;

SELECT f(p_parameter_5 =>10) FROM DUAL;

DESCRIBE user_source

SELECT TEXT 
FROM user_source
WHERE type='FUNCTION'
ORDER BY line;


DROP function f;

-- Debugging pl/sql subprograms using the sql developer debugger
GRANT DEBUG ANY PROCEDURE TO ora61;
GRANT DEBUG CONNECT SESSION TO ora61 ;

-- the procedure function
create or replace procedure add_job_history (
    p_emp_id job_history.employee_id%TYPE
    p_start_date job_history.start_date%TYPE
    p_end_date job_history.end_date%TYPE
     p_job_id job_history.job_id%TYPE
     p_department_id job_history.department_id%type
)
IS
BEGIN
    INSERT INTO job_history(employee_id,start_date,end_date,job_id,department_id)
    VALUES(p_emp_id,p_start_date,p_end_date,p_job_id,p_department_id);
    END add_job_history;

    -- DEBUGGING a procedure
    CREATE OR REPLACE PROCEDURE emp_list(pmaxrows IN NUMBER) AS 
    CURSOR emp_cursor IS     
    SELECT d.department_name,
    e.employee_id,
    e.last_name,
    e.salary,
    e.commission_pct
    FROM departments d,
    employees e    
    WHERE d.department_id=e.department_id;
    emp_record emp_cursor %ROWTYPE ;
    type emp_tab_type IS TABLE OF emp_cursor %ROWTYPE INDEX BY BINARY_INTEGER;
    emp_tab emp_tab_type;
    i NUMBER :=1;
    v_city VARCHAR2(30);

    BEGIN 
        OPEN emp_cursor;
        FETCH emp_cursor
        INTO emp_record;
        emp_tab(i):=emp_record;
        WHILE (emp_cursor %FOUND )
            AND(i<=pmaxrows)
        LOOP 
            i:=i+1;
            FETCH emp_cursor
            INTO emp_record;
            emp_tab(i):=emp_record;
            v_city:=get_location(emp_record.department_name);
            DBMS_OUTPUT.PUT_LINE('Employee '|| emp_record.last_name||' Works in '||v_city);
        END LOOP;

        CLOSE emp_cursor   ;
        FOR j in REVERSE 1..i
        LOOP
            DBMS_OUTPUT.PUT_LINE(emp_tab(j).last_name);
        END LOOP;
        END emp_list;

-- Debugging a procedure creating a new get_location fucntion
CREATE OR REPLACE FUNCTION get_location(p_deptname IN varchar2)
 RETURN VARCHAR2 AS 
 v_loc_id NUMBER;
 v_city VARCHAR2(30);
 BEGIN
    SELECT d.location_id,
    l.city
    INTO v_loc_it,
    v_city
    FROM departments d, locations l 
    WHERE UPPER (department_name) = UPPER (p_deptname)
    AND d.location_id=l.location_id;
    RETURN v_city;
    END get_location; 
 /
 
 
 
 
 -- #############################################################################################################
 --                     ******************** Chapter 4 creating Packages************
-- #############################################################################################################
-- creating package
CREATE OR REPLACE PACKAGE test_pkg IS 
PROCEDURE add_dept(
    p_name VARCHAR2,
    p_loc NUMBER);
    FUNCTION tax(p_value IN NUMBER)
    RETURN NUMBER;
    END test_pkg;
    /
-- creating package body
    CREATE OR REPLACE PACKAGE BODY test_pkg IS     
    PROCEDURE add_dept(
        p_name VARCHAR2,
        p_loc NUMBER)
    IS 
    BEGIN
        INSERT INTO departments(department_id, department_name, location_id)
        VALUES (departments_seq.NEXTVAL, p_name, p_loc);
        END add_dept;
        FUNCTION tax (p_value IN NUMBER)
        RETURN NUMBER IS 
        BEGIN
            RETURN(p_value*0.08) ;
            END tax;
            END test_pkg;
            /
set serveroutput on;
-- executing the package
EXECUTE test_pkg.add_dept('TEST',1800);
EXECUTE test_pkg.add_dept('Ttsas',1800);
-- 
SELECT department_id, department_name, location_id FROM departments;




-- syntax
CREATE [OR REPLACE ] PACKAGE package_name IS|AS 
public type and variable declarations
subprogram specifications
END [package_name];

-- package specification
-- the package spec with a public variable and a 
-- public procedure that are accessible from outside the package.

CREATE OR REPLACE PACKAGE comm_pkg IS   
v_std_comm NUMBER :=0.10;--initialized to 0.10
Procedure reset_comm(p_new_comm NUMBER);
END comm_pkg;
/

--  CREATING A Package body

CREATE [OR REPLACE ]PACKAGE  BODY package_name IS|AS    
private type and variable declarations
subprogram bodies
[BEGIN initialization statements]
END [package_name];


-- example of a package body
CREATE OR REPLACE PACKAGE BODY comm_pkg IS     
FUNCTION validate (p_comm NUMBER ) RETURN BOOLEAN IS     
v_max_comm employees.commission_pct%TYPE;

BEGIN 
    SELECT MAX (commission_pct) INTO    v_max_comm
    FROM employees
    RETURN (p_comm BETWEEN 0.0 AND v_max_comm);
    END validate;

PROCEDURE reset_comm (p_new_comm NUMBER) IS 
    BEGIN
        IF validate(p_new_comm ) THEN   
            v_std_comm :=p_new_comm;--reset public var
        ELSE RAISE_APPLICATION_ERROR(
            -20210,'BAD COMMISSION'
        );
        END IF;
        END reset_comm;
        END comm_pkg;

        -- Warning: Package Body created with compilation errors.

-- invoking the Package subprograms
-- invoke a function within the same packages;
CREATE OR REPLACE PACKAGE BODY comm_pkg IS...
PROCEDURE reset_comm(p_new_comm NUMBER) IS    
BEGIN
    IF validate(p_new_comm) THEN
    v_std_comm:=p_new_comm;
    ELSE...
    END IF;
    END rese;
    END comm_pkg;
    -- invoke a package procedure from sql plus
    EXECUTE comm_pkg.reset_comm(0.15)
    -- invoke a package procedure in a different schema:
    EXECUTE scott.comm_pkg.reset_comm(0.15)

    -- ####### Creating and Using Bodiless packages
    CREATE OR REPLACE PACKAGE   global_consts IS    
    c_mile_2_kilo CONSTANT  NUMBER :=1.6093;
    c_kilo_2_mile  CONSTANT  NUMBER :=0.6214;
    c_yard_2_meter CONSTANT  NUMBER :=0.9144;
    c_meter_2_yard CONSTANT  NUMBER :=1.0936;
    END global_consts;

    SET SERVEROUTPUT ON   
    BEGIN
        DBMS_OUTPUT.PUT_LINE('20 miles = '||
        20*global_consts.c_mile_2_kilo|| ' Km');
    END;

    SET SERVEROUTPUT ON   
    CREATE FUNCTION mtr2yrd(p_m NUMBER) RETURN NUMBER IS 
    BEGIN
        RETURN(p_m*global_consts.c_meter_2_yard);
        END mtr2yrd;
        /
    EXECUTE DBMS_OUTPUT.PUT_LINE(mtr2yrd(1))

    -- Viewing Packages by Using the Data dictionary
    -- view the package specification.
    SELECT text 
    FROM user_source
    WHERE name='COMM_PKG' AND type='PACKAGE'
    ORDER BY LINE;

    -- view the package bidy.
    SELECT text   
    FROM user_source
    WHERE name='COMM_PKG' AND type='PACKAGE BODY'
    ORDER BY LINE;

    -- Remove the package specification and body
    DROP PACKAGE package_name;
    -- Remove the package body only
    DROP PACKAGE BODY package_name;

    lukeb.co/sql_jobs_db


 -- #############################################################################################################
 --                     ******************** Chapter 5 working with Packages************
-- #############################################################################################################
-- overloading procedures example (creating package specification)
CREATE OR REPLACE PACKAGE  dept_pkg IS
      PROCEDURE add_department
      (p_deptno departments.department_id%TYPE, p_name departments.department_name%TYPE:='Unknown',
      p_loc departments.location_id%TYPE:=1700);

      PROCEDURE add_department
      (p_deptno departments.department_id%TYPE, p_name departments.department_name%TYPE:='Unknown',
      p_loc departments.location_id%TYPE:=1700);
END dept_pkg;
/
-- overloading procedures example (creating the package body)
-- package body of package defined on previous slide.
CREATE OR REPLACE PACKAGE BODY dept_pkg IS 
PROCEDURE add_department --first procedure's declaration
(p_deptno departments.deparment_id%TYPE,
p_name departments.department_name%TYPE,
p_loc departments.location_id%TYPE:=1700) IS 
BEGIN
  INSERT INTO departments(deparment_id, department_name, location_id)
  VALUES(p_deptno, p_name, p_loc);
END add_department;
PROCEDURE
add_department--Second procedure's declaration
(p_name departments.department_name%TYPE:='Unknown'
p_loc departments.location_id%TYPE:=1700) IS
BEGIN
INSERT INTO departments (deparment_id, department_name, location_id) 
values(departments_seq.NEXTVAL, p_name, p_loc);
END add_department;
END dept_pkg;/


 -- #############################################################################################################
 --                     ******************** Chapter 6 working with Packages************
-- #############################################################################################################

 -- #############################################################################################################
 --                     ******************** Chapter 7 working with Packages************
-- #############################################################################################################

 -- #############################################################################################################
 --                     ******************** Chapter 8 working with Packages************
-- #############################################################################################################

 -- #############################################################################################################
 --                     ******************** Chapter 9 Creating Triggers ************
-- #############################################################################################################
trigger is a pl sql block stored in database like procedure function.
time specify kore rakhbe, jei specification diso shei shomoy trigger executable hobe. onekta alarm er moto.

time set kore rakhbe AUTOMATICALLY oi trigger e thaka pl sql code execute hobe.
condition set kore rakhba specified condition ghotle ba true hole trigger AUTOMATICALLY execute hoy.
a trigger is defined in table view schema . 

***  DML, DDL, database operation servererror, logon logoff, startup, shutdown
trigger 2 , database trigger(dml ddl occurs), APPLICATION trigger

use trigger for security, audit, data integrity, referencial integrity

simple dml before after instead of compound , non dml trigger 
trigger event type kon dml statement kokhon exevute hobe (insert update delete)

trigger body determine ki action perform korebe plsql blok naki CALL to procedure. 
create trigger statement diye trigger kokhon 

+



-- creating a trigger 
CREATE OR REPLACE trigger secure_emp 
before insert on employees
begin
IF (TO_CHAR (sysdate , 'DY') IN ('SAT', 'SUN')) OR (TO_CHAR(sysdate, 'HH24:MI') NOT BETWEEN '08:00' AND '18:00') THEN 
RAISE_APPLICATION_ERROR( -20500 ,'khankir pola kamer shomoy kaj koros na you dont have a life office hour e entry de');
end if ; 
END;
/

insert into employees (employee_id, last_name, first_name, email, hire_date, job_id, salary, department_id)
values(3004, 'Marc', 'manson', 'mmson', sysdate, 'IT_PROG', 5398893, 60);


-- #############################################################################################################
--                     ******************** Chapter 10 working with triggers ************
-- #############################################################################################################

-- #############################################################################################################
--                     ******************** Chapter 5 working with Packages************
-- #############################################################################################################
